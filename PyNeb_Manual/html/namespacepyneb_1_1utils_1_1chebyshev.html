<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PyNeb: pyneb.utils.chebyshev Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyNeb
   &#160;<span id="projectnumber">1.1.2</span>
   </div>
   <div id="projectbrief">PyNeb Reference Manua</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacepyneb_1_1utils_1_1chebyshev.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pyneb.utils.chebyshev Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f91018c86380adf38318e4e224279e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a1f91018c86380adf38318e4e224279e7">poly2cheb</a> (pol)</td></tr>
<tr class="separator:a1f91018c86380adf38318e4e224279e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640344fc14aa36e14d0e93eba4411188"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a640344fc14aa36e14d0e93eba4411188">cheb2poly</a> (cs)</td></tr>
<tr class="separator:a640344fc14aa36e14d0e93eba4411188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14ae6340a5a9e3c93c1bb720f4e5a04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ad14ae6340a5a9e3c93c1bb720f4e5a04">chebline</a> (off, scl)</td></tr>
<tr class="separator:ad14ae6340a5a9e3c93c1bb720f4e5a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedf5cf14ea9229321fc5e4043c42a0d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#abedf5cf14ea9229321fc5e4043c42a0d">chebfromroots</a> (roots)</td></tr>
<tr class="separator:abedf5cf14ea9229321fc5e4043c42a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a85eb72ae35925336a6b550dec3f02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a06a85eb72ae35925336a6b550dec3f02">chebadd</a> (c1, c2)</td></tr>
<tr class="separator:a06a85eb72ae35925336a6b550dec3f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c70b217882a8c0a731ce9fdf743f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ac07c70b217882a8c0a731ce9fdf743f0">chebsub</a> (c1, c2)</td></tr>
<tr class="separator:ac07c70b217882a8c0a731ce9fdf743f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09f8accee50bd964e03071a659a7b5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ab09f8accee50bd964e03071a659a7b5f">chebmulx</a> (cs)</td></tr>
<tr class="separator:ab09f8accee50bd964e03071a659a7b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5aab8be2c47559d4489fd1dac11f75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#aca5aab8be2c47559d4489fd1dac11f75">chebmul</a> (c1, c2)</td></tr>
<tr class="separator:aca5aab8be2c47559d4489fd1dac11f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84df28815f29342a7cdce9b95470f02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#aa84df28815f29342a7cdce9b95470f02">chebdiv</a> (c1, c2)</td></tr>
<tr class="separator:aa84df28815f29342a7cdce9b95470f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab647ff3aa7750a09b934b98cddd4c90d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ab647ff3aa7750a09b934b98cddd4c90d">chebpow</a></td></tr>
<tr class="separator:ab647ff3aa7750a09b934b98cddd4c90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed2b9248c247449584904025ec9d460"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a1ed2b9248c247449584904025ec9d460">chebder</a></td></tr>
<tr class="separator:a1ed2b9248c247449584904025ec9d460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233e686a07b9935c74ce1e053f0c5f5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a233e686a07b9935c74ce1e053f0c5f5f">chebint</a></td></tr>
<tr class="separator:a233e686a07b9935c74ce1e053f0c5f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7442e9a3a00e1ca04a2283877b15a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a7f7442e9a3a00e1ca04a2283877b15a8">chebval</a> (x, cs)</td></tr>
<tr class="separator:a7f7442e9a3a00e1ca04a2283877b15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9deae857486c8ee69362ded985b09d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#aa9deae857486c8ee69362ded985b09d8">chebvander</a> (x, deg)</td></tr>
<tr class="separator:aa9deae857486c8ee69362ded985b09d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb5eb95525fd0572aea52fcd2a12c6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a6bb5eb95525fd0572aea52fcd2a12c6c">chebfit</a></td></tr>
<tr class="separator:a6bb5eb95525fd0572aea52fcd2a12c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f01a14e36b415a2f3ebc67c95cceb26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a2f01a14e36b415a2f3ebc67c95cceb26">chebroots</a> (cs)</td></tr>
<tr class="separator:a2f01a14e36b415a2f3ebc67c95cceb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac57e95809a1f627400a7c3a34606f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a5ac57e95809a1f627400a7c3a34606f7">chebpts1</a> (npts)</td></tr>
<tr class="separator:a5ac57e95809a1f627400a7c3a34606f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224bc370de0cfa204c3ac15d626d13e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a224bc370de0cfa204c3ac15d626d13e3">chebpts2</a> (npts)</td></tr>
<tr class="separator:a224bc370de0cfa204c3ac15d626d13e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa4a022e6ddacd362b83964da5cc5d044"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#aa4a022e6ddacd362b83964da5cc5d044">__all__</a></td></tr>
<tr class="separator:aa4a022e6ddacd362b83964da5cc5d044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a0ced0266ea763728bee66b728cbff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ab0a0ced0266ea763728bee66b728cbff">chebtrim</a> = trimcoef</td></tr>
<tr class="separator:ab0a0ced0266ea763728bee66b728cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5a8e86847ca6ea59d2a192f28604d4"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#abd5a8e86847ca6ea59d2a192f28604d4">chebdomain</a> = np.array([-1,1])</td></tr>
<tr class="separator:abd5a8e86847ca6ea59d2a192f28604d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadda3e168aefd0f4b28a9d7cab6ad412"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#aadda3e168aefd0f4b28a9d7cab6ad412">chebzero</a> = np.array([0])</td></tr>
<tr class="separator:aadda3e168aefd0f4b28a9d7cab6ad412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07bc7eff7bee500f8644792e4f69712"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#ad07bc7eff7bee500f8644792e4f69712">chebone</a> = np.array([1])</td></tr>
<tr class="separator:ad07bc7eff7bee500f8644792e4f69712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce7dddbafb225b28442052d01115054"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html#a0ce7dddbafb225b28442052d01115054">chebx</a> = np.array([0,1])</td></tr>
<tr class="separator:a0ce7dddbafb225b28442052d01115054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Objects for dealing with Chebyshev series.

This module provides a number of objects (mostly functions) useful for
dealing with Chebyshev series, including a `Chebyshev` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `chebdomain` -- Chebyshev series default domain, [-1,1].
- `chebzero` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 0.
- `chebone` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 1.
- `chebx` -- (Coefficients of the) Chebyshev series for the identity map,
  ``f(x) = x``.

Arithmetic
----------
- `chebadd` -- add two Chebyshev series.
- `chebsub` -- subtract one Chebyshev series from another.
- `chebmul` -- multiply two Chebyshev series.
- `chebdiv` -- divide one Chebyshev series by another.
- `chebpow` -- raise a Chebyshev series to an positive integer power
- `chebval` -- evaluate a Chebyshev series at given points.

Calculus
--------
- `chebder` -- differentiate a Chebyshev series.
- `chebint` -- integrate a Chebyshev series.

Misc Functions
--------------
- `chebfromroots` -- create a Chebyshev series with specified roots.
- `chebroots` -- find the roots of a Chebyshev series.
- `chebvander` -- Vandermonde-like matrix for Chebyshev polynomials.
- `chebfit` -- least-squares fit returning a Chebyshev series.
- `chebpts1` -- Chebyshev points of the first kind.
- `chebpts2` -- Chebyshev points of the second kind.
- `chebtrim` -- trim leading coefficients from a Chebyshev series.
- `chebline` -- Chebyshev series representing given straight line.
- `cheb2poly` -- convert a Chebyshev series to a polynomial.
- `poly2cheb` -- convert a polynomial to a Chebyshev series.

Classes
-------
- `Chebyshev` -- A Chebyshev series class.

See also
--------
`numpy.polynomial`

Notes
-----
The implementations of multiplication, division, integration, and
differentiation use the algebraic identities [1]_:

.. math ::
    T_n(x) = \\frac{z^n + z^{-n}}{2} \\\\
    z\\frac{dx}{dz} = \\frac{z - z^{-1}}{2}.

where

.. math :: x = \\frac{z + z^{-1}}{2}.

These identities allow a Chebyshev series to be expressed as a finite,
symmetric Laurent series.  In this module, this sort of Laurent series
is referred to as a "z-series."

References
----------
.. [1] A. T. Benjamin, et al., "Combinatorial Trigonometry with Chebyshev
  Polynomials," *Journal of Statistical Planning and Inference 14*, 2008
  (preprint: http://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf, pg. 4)</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a640344fc14aa36e14d0e93eba4411188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.cheb2poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a Chebyshev series to a polynomial.

Convert an array representing the coefficients of a Chebyshev series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
cs : array_like
    1-d array containing the Chebyshev series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-d array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2cheb

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; c = P.Chebyshev(range(4))
&gt;&gt;&gt; c
Chebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; p = c.convert(kind=P.Polynomial)
&gt;&gt;&gt; p
Polynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])
&gt;&gt;&gt; P.cheb2poly(range(4))
array([ -2.,  -8.,   4.,  12.])</pre> 
</div>
</div>
<a class="anchor" id="a06a85eb72ae35925336a6b550dec3f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebadd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add one Chebyshev series to another.

Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Chebyshev series of their sum.

See Also
--------
chebsub, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Chebyshev series
is a Chebyshev series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebadd(c1,c2)
array([ 4.,  4.,  4.])</pre> 
</div>
</div>
<a class="anchor" id="a1ed2b9248c247449584904025ec9d460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Differentiate a Chebyshev series.

Returns the series `cs` differentiated `m` times.  At each iteration the
result is multiplied by `scl` (the scaling factor is for use in a linear
change of variable).  The argument `cs` is the sequence of coefficients
from lowest order "term" to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
cs: array_like
    1-d array of Chebyshev series coefficients ordered from low to high.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)

Returns
-------
der : ndarray
    Chebyshev series of the derivative.

See Also
--------
chebint

Notes
-----
In general, the result of differentiating a C-series needs to be
"re-projected" onto the C-series basis set. Thus, typically, the
result of this function is "un-intuitive," albeit correct; see Examples
section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; cs = (1,2,3,4)
&gt;&gt;&gt; C.chebder(cs)
array([ 14.,  12.,  24.])
&gt;&gt;&gt; C.chebder(cs,3)
array([ 96.])
&gt;&gt;&gt; C.chebder(cs,scl=-1)
array([-14., -12., -24.])
&gt;&gt;&gt; C.chebder(cs,2,-1)
array([ 12.,  96.])</pre> 
</div>
</div>
<a class="anchor" id="aa84df28815f29342a7cdce9b95470f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebdiv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Divide one Chebyshev series by another.

Returns the quotient-with-remainder of two Chebyshev series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Chebyshev series coefficients representing the quotient and
    remainder.

See Also
--------
chebadd, chebsub, chebmul, chebpow

Notes
-----
In general, the (polynomial) division of one C-series by another
results in quotient and remainder terms that are not in the Chebyshev
polynomial basis set.  Thus, to express these results as C-series, it
is typically necessary to "re-project" the results onto said basis
set, which typically produces "un-intuitive" (but correct) results;
see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebdiv(c1,c2) # quotient "intuitive," remainder not
(array([ 3.]), array([-8., -4.]))
&gt;&gt;&gt; c2 = (0,1,2,3)
&gt;&gt;&gt; C.chebdiv(c2,c1) # neither "intuitive"
(array([ 0.,  2.]), array([-2., -4.]))</pre> 
</div>
</div>
<a class="anchor" id="a6bb5eb95525fd0572aea52fcd2a12c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebfit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Least squares fit of Chebyshev series to data.

Fit a Chebyshev series ``p(x) = p[0] * T_{0}(x) + ... + p[deg] *
T_{deg}(x)`` of degree `deg` to points `(x, y)`. Returns a vector of
coefficients `p` that minimises the squared error.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.
    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Chebyshev coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : present when `full` = True
    Residuals of the least-squares fit, the effective rank of the
    scaled Vandermonde matrix and its singular values, and the
    specified value of `rcond`. For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebval : Evaluates a Chebyshev series.
chebvander : Vandermonde matrix of Chebyshev series.
polyfit : least squares fit using polynomials.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution are the coefficients ``c[i]`` of the Chebyshev series
``T(x)`` that minimizes the squared error

``E = \\sum_j |y_j - T(x_j)|^2``.

This problem is solved by setting up as the overdetermined matrix
equation

``V(x)*c = y``,

where ``V`` is the Vandermonde matrix of `x`, the elements of ``c`` are
the coefficients to be solved for, and the elements of `y` are the
observed values.  This equation is then solved using the singular value
decomposition of ``V``.

If some of the singular values of ``V`` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coeficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Chebyshev series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------</pre> 
</div>
</div>
<a class="anchor" id="abedf5cf14ea9229321fc5e4043c42a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebfromroots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a Chebyshev series with the given roots.

Return the array of coefficients for the C-series whose roots (a.k.a.
"zeros") are given by *roots*.  The returned array of coefficients is
ordered from lowest order "term" to highest, and zeros of multiplicity
greater than one must be included in *roots* a number of times equal
to their multiplicity (e.g., if `2` is a root of multiplicity three,
then [2,2,2] must be in *roots*).

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-d array of the C-series' coefficients, ordered from low to
    high.  If all roots are real, ``out.dtype`` is a float type;
    otherwise, ``out.dtype`` is a complex type, even if all the
    coefficients in the result are real (see Examples below).

See Also
--------
polyfromroots

Notes
-----
What is returned are the :math:`c_i` such that:

.. math::

    \\sum_{i=0}^{n} c_i*T_i(x) = \\prod_{i=0}^{n} (x - roots[i])

where ``n == len(roots)`` and :math:`T_i(x)` is the `i`-th Chebyshev
(basis) polynomial over the domain `[-1,1]`.  Note that, unlike
`polyfromroots`, due to the nature of the C-series basis set, the
above identity *does not* imply :math:`c_n = 1` identically (see
Examples).

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.chebyshev as C
&gt;&gt;&gt; C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0.  , -0.25,  0.  ,  0.25])
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([ 1.5+0.j,  0.0+0.j,  0.5+0.j])</pre> 
</div>
</div>
<a class="anchor" id="a233e686a07b9935c74ce1e053f0c5f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lbnd</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integrate a Chebyshev series.

Returns, as a C-series, the input C-series `cs`, integrated `m` times
from `lbnd` to `x`.  At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `cs` is a sequence of
coefficients, from lowest order C-series "term" to highest, e.g.,
[1,2,3] represents the series :math:`T_0(x) + 2T_1(x) + 3T_2(x)`.

Parameters
----------
cs : array_like
    1-d array of C-series coefficients, ordered from low to high.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)

Returns
-------
S : ndarray
    C-series coefficients of the integral.

Raises
------
ValueError
    If ``m &lt; 1``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
chebder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to :math:`1/a`
- perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "re-projected" onto the C-series basis set.  Thus, typically,
the result of this function is "un-intuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; cs = (1,2,3)
&gt;&gt;&gt; C.chebint(cs)
array([ 0.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(cs,3)
array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,
        0.00625   ])
&gt;&gt;&gt; C.chebint(cs, k=3)
array([ 3.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(cs,lbnd=-2)
array([ 8.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(cs,scl=-2)
array([-1.,  1., -1., -1.])</pre> 
</div>
</div>
<a class="anchor" id="ad14ae6340a5a9e3c93c1bb720f4e5a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Chebyshev series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Chebyshev series for
    ``off + scl*x``.

See Also
--------
polyline

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.chebyshev as C
&gt;&gt;&gt; C.chebline(3,2)
array([3, 2])
&gt;&gt;&gt; C.chebval(-3, C.chebline(3,2)) # should be -3
-3.0</pre> 
</div>
</div>
<a class="anchor" id="aca5aab8be2c47559d4489fd1dac11f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply one Chebyshev series by another.

Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their product.

See Also
--------
chebadd, chebsub, chebdiv, chebpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Chebyshev polynomial basis set.  Thus, to express
the product as a C-series, it is typically necessary to "re-project"
the product onto said basis set, which typically produces
"un-intuitive" (but correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebmul(c1,c2) # multiplication requires "reprojection"
array([  6.5,  12. ,  12. ,   4. ,   1.5])</pre> 
</div>
</div>
<a class="anchor" id="ab09f8accee50bd964e03071a659a7b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebmulx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply a Chebyshev series by x.

Multiply the polynomial `cs` by x, where x is the independent
variable.


Parameters
----------
cs : array_like
    1-d array of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
.. versionadded:: 1.5.0</pre> 
</div>
</div>
<a class="anchor" id="ab647ff3aa7750a09b934b98cddd4c90d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebpow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxpower</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise a Chebyshev series to a power.

Returns the Chebyshev series `cs` raised to the power `pow`. The
arguement `cs` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``

Parameters
----------
cs : array_like
    1d array of chebyshev series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to umanageable size. Default is 16

Returns
-------
coef : ndarray
    Chebyshev series of power.

See Also
--------
chebadd, chebsub, chebmul, chebdiv

Examples
--------</pre> 
</div>
</div>
<a class="anchor" id="a5ac57e95809a1f627400a7c3a34606f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebpts1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>npts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Chebyshev points of the first kind.

Chebyshev points of the first kind are the set ``{cos(x_k)}``,
where ``x_k = pi*(k + .5)/npts`` for k in ``range(npts}``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----
.. versionadded:: 1.5.0</pre> 
</div>
</div>
<a class="anchor" id="a224bc370de0cfa204c3ac15d626d13e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebpts2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>npts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Chebyshev points of the second kind.

Chebyshev points of the second kind are the set ``{cos(x_k)}``,
where ``x_k = pi*/(npts - 1)`` for k in ``range(npts}``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----
.. versionadded:: 1.5.0</pre> 
</div>
</div>
<a class="anchor" id="a2f01a14e36b415a2f3ebc67c95cceb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebroots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the roots of a Chebyshev series.

Return the roots (a.k.a "zeros") of the C-series represented by `cs`,
which is the sequence of the C-series' coefficients from lowest order
"term" to highest, e.g., [1,2,3] represents the C-series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
cs : array_like
    1-d array of C-series coefficients ordered from low to high.

Returns
-------
out : ndarray
    Array of the roots.  If all the roots are real, then so is the
    dtype of ``out``; otherwise, ``out``'s dtype is complex.

See Also
--------
polyroots

Notes
-----
Algorithm(s) used:

Remember: because the C-series basis set is different from the
"standard" basis set, the results of this function *may* not be what
one is expecting.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial as P
&gt;&gt;&gt; import numpy.polynomial.chebyshev as C
&gt;&gt;&gt; P.polyroots((-1,1,-1,1)) # x^3 - x^2 + x - 1 has two complex roots
array([ -4.99600361e-16-1.j,  -4.99600361e-16+1.j,   1.00000e+00+0.j])
&gt;&gt;&gt; C.chebroots((-1,1,-1,1)) # T3 - T2 + T1 - T0 has only real roots
array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])</pre> 
</div>
</div>
<a class="anchor" id="ac07c70b217882a8c0a731ce9fdf743f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebsub </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subtract one Chebyshev series from another.

Returns the difference of two Chebyshev series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their difference.

See Also
--------
chebadd, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Chebyshev
series is a Chebyshev series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebsub(c1,c2)
array([-2.,  0.,  2.])
&gt;&gt;&gt; C.chebsub(c2,c1) # -C.chebsub(c1,c2)
array([ 2.,  0., -2.])</pre> 
</div>
</div>
<a class="anchor" id="a7f7442e9a3a00e1ca04a2283877b15a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a Chebyshev series.

If `cs` is of length `n`, this function returns :

``p(x) = cs[0]*T_0(x) + cs[1]*T_1(x) + ... + cs[n-1]*T_{n-1}(x)``

If x is a sequence or array then p(x) will have the same shape as x.
If r is a ring_like object that supports multiplication and addition
by the values in `cs`, then an object of the same type is returned.

Parameters
----------
x : array_like, ring_like
    Array of numbers or objects that support multiplication and
    addition with themselves and with the elements of `cs`.
cs : array_like
    1-d array of Chebyshev coefficients ordered from low to high.

Returns
-------
values : ndarray, ring_like
    If the return is an ndarray then it has the same shape as `x`.

See Also
--------
chebfit

Examples
--------

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------</pre> 
</div>
</div>
<a class="anchor" id="aa9deae857486c8ee69362ded985b09d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.chebvander </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Vandermonde matrix of given degree.

Returns the Vandermonde matrix of degree `deg` and sample points `x`.
This isn't a true Vandermonde matrix because `x` can be an arbitrary
ndarray and the Chebyshev polynomials aren't powers. If ``V`` is the
returned matrix and `x` is a 2d array, then the elements of ``V`` are
``V[i,j,k] = T_k(x[i,j])``, where ``T_k`` is the Chebyshev polynomial
of degree ``k``.

Parameters
----------
x : array_like
    Array of points. The values are converted to double or complex
    doubles. If x is scalar it is converted to a 1D array.
deg : integer
    Degree of the resulting matrix.

Returns
-------
vander : Vandermonde matrix.
    The shape of the returned matrix is ``x.shape + (deg+1,)``. The last
    index is the degree.</pre> 
</div>
</div>
<a class="anchor" id="a1f91018c86380adf38318e4e224279e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pyneb.utils.chebyshev.poly2cheb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a polynomial to a Chebyshev series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Chebyshev series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-d array containing the polynomial coefficients

Returns
-------
cs : ndarray
    1-d array containing the coefficients of the equivalent Chebyshev
    series.

See Also
--------
cheb2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; p = P.Polynomial(range(4))
&gt;&gt;&gt; p
Polynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; c = p.convert(kind=P.Chebyshev)
&gt;&gt;&gt; c
Chebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])
&gt;&gt;&gt; P.poly2cheb(range(4))
array([ 1.  ,  3.25,  1.  ,  0.75])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa4a022e6ddacd362b83964da5cc5d044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list __all__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacepyneb_1_1utils_1_1chebyshev.html">    1</a></span>&#160;= [<span class="stringliteral">&#39;chebzero&#39;</span>, <span class="stringliteral">&#39;chebone&#39;</span>, <span class="stringliteral">&#39;chebx&#39;</span>, <span class="stringliteral">&#39;chebdomain&#39;</span>, <span class="stringliteral">&#39;chebline&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        <span class="stringliteral">&#39;chebadd&#39;</span>, <span class="stringliteral">&#39;chebsub&#39;</span>, <span class="stringliteral">&#39;chebmulx&#39;</span>, <span class="stringliteral">&#39;chebmul&#39;</span>, <span class="stringliteral">&#39;chebdiv&#39;</span>, <span class="stringliteral">&#39;chebpow&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        <span class="stringliteral">&#39;chebval&#39;</span>, <span class="stringliteral">&#39;chebder&#39;</span>, <span class="stringliteral">&#39;chebint&#39;</span>, <span class="stringliteral">&#39;cheb2poly&#39;</span>, <span class="stringliteral">&#39;poly2cheb&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        <span class="stringliteral">&#39;chebfromroots&#39;</span>, <span class="stringliteral">&#39;chebvander&#39;</span>, <span class="stringliteral">&#39;chebfit&#39;</span>, <span class="stringliteral">&#39;chebtrim&#39;</span>, <span class="stringliteral">&#39;chebroots&#39;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        <span class="stringliteral">&#39;chebpts1&#39;</span>, <span class="stringliteral">&#39;chebpts2&#39;</span>, <span class="stringliteral">&#39;Chebyshev&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd5a8e86847ca6ea59d2a192f28604d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple chebdomain = np.array([-1,1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad07bc7eff7bee500f8644792e4f69712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple chebone = np.array([1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0a0ced0266ea763728bee66b728cbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chebtrim = trimcoef</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ce7dddbafb225b28442052d01115054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple chebx = np.array([0,1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadda3e168aefd0f4b28a9d7cab6ad412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple chebzero = np.array([0])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepyneb.html">pyneb</a></li><li class="navelem"><a class="el" href="namespacepyneb_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacepyneb_1_1utils_1_1chebyshev.html">chebyshev</a></li>
    <li class="footer">Generated on Mon Jul 3 2017 16:06:41 for PyNeb by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
